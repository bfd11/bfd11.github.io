var wt=Object.defineProperty;var ft=(g,t,e)=>t in g?wt(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var z=(g,t,e)=>(ft(g,typeof t!="symbol"?t+"":t,e),e);import{fy as It,ab as A,fz as yt,fA as F,aZ as gt,aC as T,a$ as B,fB as kt,fC as P,fD as st,a_ as dt,fE as vt,fF as pt,fG as At,fH as nt,fI as D,bY as W,fJ as S,fK as M,S as b,fL as ut,fM as G,v as R,bo as q,bp as ot,fN as $,bz as _,b0 as ct,cf as O,fO as at,fP as Ct,fQ as lt,fR as N,c5 as et,fS as U,fT as j,bb as ht,fU as C,fV as c,ae as Ot,bS as X,bU as zt,fW as Y,fX as Tt}from"./index-40f6b818.js";var Wt=It(function(g,t,e){g[e?0:1].push(t)},function(){return[[],[]]});const rt=Wt,tt={value:0};class mt{constructor(t){z(this,"depositCache",{});z(this,"withdrawCache",{});this.type=t}getId(){return`beefy-zap-${this.type}`}isCorrectAmmType(t){return t.type===this.type}async getCommonOptionData(t,e){const n=A(e,t),s=yt(e,n.chainId);if(s===void 0||s.length===0)return null;let o=e.entities.amms.byChainId[n.chainId];if(o===void 0||o.length===0||(o=o.filter(u=>u.type===this.type),o===void 0||o.length===0)||!F(n)||n.assetIds.length!==2)return null;for(let u=0;u<n.assetIds.length;++u)if(!gt(e,n.chainId,n.assetIds[u]))return console.warn(this.getId(),`${n.assetIds[u]} not loaded`),null;const r=T(e,n.chainId,n.depositTokenAddress);if(!B(r)||!r.ammId)return null;const a=kt(e,r.ammId);if(!a||!this.isCorrectAmmType(a))return null;const i=P(e,n.chainId),d=st(e,n.chainId),p=n.assetIds.map(u=>dt(e,n.chainId,u)),m=vt(p,i),w=pt(e,a.id);if(!w)return null;const l=At(p,i,d);return{vault:n,zapTokens:l,zap:w,amm:a,lpTokens:m,native:d,wnative:i}}async getDepositOptionsFor(t,e){if(t in this.depositCache)return this.depositCache[t];if(!nt(e,t))return null;const n=await this.getCommonOptionData(t,e);if(!n)return null;const{vault:s,zapTokens:o,zap:r,amm:a,lpTokens:i}=n;return this.depositCache[s.id]=o.map(d=>{const p=[d].map(m=>m.address.toLowerCase());return{id:D(this.getId(),t,s.chainId,p),type:"zap",mode:W.Deposit,providerId:this.getId(),vaultId:t,chainId:s.chainId,tokensId:S(s.chainId,p),tokenAddresses:p,zap:r,amm:a,lpTokens:i,fee:tt}}),this.depositCache[s.id]}async getDepositQuoteFor(t,e,n){if(!this.isBeefyZapOption(t))throw new Error(`Wrong option type passed to ${this.getId()}`);const s=A(n,t.vaultId);if(!F(s))throw new Error("Only standard vaults are supported");if(e.length!==1)throw new Error("Only 1 input token supported");const o=M(e);if(o.amount.lte(b))throw new Error("Quote called with 0 input");const r=P(n,s.chainId),a=o.token,i=ut(o.amount,a.decimals),d=G(a,r),p=t.lpTokens.find(h=>h.address.toLowerCase()!==d.address.toLowerCase()),m=R(n,t.chainId),w=T(n,s.chainId,s.depositTokenAddress),l=await q(m),u=new ot.MultiCall(l,m.multicallAddress);return this.getDepositQuoteForType({web3:l,depositToken:w,chain:m,option:t,swapTokenIn:d,amounts:e,multicall:u,swapTokenOut:p,userAmountInWei:i,vault:s,userInput:o})}async getDepositStep(t,e,n,s){if(!this.isBeefyZapOption(e))throw new Error(`Wrong option type passed to ${this.getId()}`);const o=A(n,e.vaultId),r=t.steps.find(p=>$(p)),a=_(n);if(!r||!$(r))throw new Error("No swap step in zap quote");const i=t.inputs[0],d=ct(i.token);return{step:"zap-in",message:s("Vault-TxnConfirm",{type:s("Deposit-noun")}),action:O.beefIn(o,i.amount,d,r,e.zap,a),pending:!1,extraInfo:{zap:!0,vaultId:o.id}}}async getWithdrawOptionsFor(t,e){if(t in this.withdrawCache)return this.withdrawCache[t];if(!nt(e,t))return null;const n=await this.getCommonOptionData(t,e);if(!n)return null;const{vault:s,zap:o,amm:r,lpTokens:a,wnative:i,native:d}=n,p=at(a,i,d).map(l=>l.address),m=[{id:D(this.getId(),t,s.chainId,p),type:"zap",mode:W.Withdraw,providerId:this.getId(),vaultId:t,chainId:s.chainId,tokensId:S(s.chainId,p),tokenAddresses:p,zap:o,amm:r,lpTokens:a,fee:tt}];return at(n.zapTokens,i,d).forEach(l=>{const u=[l].map(h=>h.address.toLowerCase());m.push({id:D(this.getId(),t,s.chainId,u),type:"zap",mode:W.Withdraw,providerId:this.getId(),vaultId:t,chainId:s.chainId,tokensId:S(s.chainId,u),tokenAddresses:u,zap:o,amm:r,lpTokens:a,fee:tt})}),this.withdrawCache[s.id]=m,this.withdrawCache[s.id]}async getWithdrawQuoteFor(t,e,n){if(!this.isBeefyZapOption(t))throw new Error(`Wrong option type passed to ${this.getId()}`);const s=A(n,t.vaultId);if(!F(s))throw new Error("Only standard vaults are supported");if(e.length!==1)throw new Error("Only 1 input token supported");const o=M(e);if(o.amount.lte(b))throw new Error("Quote called with 0 input");const r=T(n,s.chainId,s.depositTokenAddress);if(!Ct(r,o.token))throw new Error(`Invalid input token ${o.token.symbol}`);const a=R(n,t.chainId),i=await q(a),d=new ot.MultiCall(i,a.multicallAddress),p=P(n,s.chainId),m=st(n,s.chainId),{shareToken:w,sharesToWithdrawWei:l,withdrawnAmountAfterFeeWei:u}=lt(o,s,n);let h=null,y=null,v=null;if(t.tokenAddresses.length===1){if(t.tokenAddresses[0].toLowerCase()===r.address.toLowerCase())throw new Error("can not quote for deposit token on zap withdraw");const I=T(n,t.chainId,t.tokenAddresses[0]);v=N(I,p,m),y=G(I,p),h=t.lpTokens.find(f=>f.address.toLowerCase()!==y.address.toLowerCase())}return this.getWithdrawQuoteForType({option:t,web3:i,multicall:d,chain:a,vault:s,amounts:e,shareToken:w,sharesToWithdrawWei:l,withdrawnToken:r,withdrawnAmountAfterFeeWei:u,swapTokenIn:h,swapTokenOut:y,actualTokenOut:v,wnative:p,native:m})}async getWithdrawStep(t,e,n,s){if(!this.isBeefyZapOption(e))throw new Error(`Wrong option type passed to ${this.getId()}`);const o=et(n,e.vaultId),r=t.steps.find(d=>$(d)),a=r&&$(r),i=_(n);return{step:a?"zap-out":"withdraw",message:s("Vault-TxnConfirm",{type:s("Withdraw-noun")}),action:a?O.beefOutAndSwap(o,t.inputs[0],r,e.zap,i):O.beefOut(o,t.inputs[0],e.zap),pending:!1,extraInfo:{zap:a,vaultId:o.id}}}isBeefyZapOption(t){return t.providerId===this.getId()}}class Et extends mt{constructor(){super("uniswapv2")}async getDepositQuoteForType({web3:t,chain:e,depositToken:n,swapTokenIn:s,swapTokenOut:o,userAmountInWei:r,option:a,vault:i,amounts:d}){const p=U(n.address,a.amm,e),m=new t.eth.Contract(j,a.zap.zapAddress),[[w]]=await p.updateAllData([[{estimate:m.methods.estimateSwap(i.earnContractAddress,s.address,r.toString(10))}]]);if(!w.estimate)throw new Error("Failed to estimate swap.");const l=new ht(w.estimate[0]),u=r.minus(l),{amountOut:h,priceImpact:y}=p.swap(l,s.address,!0),{addAmountA:v,addAmountB:I,liquidity:f}=p.addLiquidity(u,s.address,h);return{id:C(a.id),optionId:a.id,type:"zap",allowances:d.filter(k=>B(k.token)).map(k=>({token:k.token,amount:k.amount,spenderAddress:a.zap.zapAddress})),inputs:d,outputs:[{token:n,amount:c(f,n.decimals)}],priceImpact:y,steps:[{type:"swap",fromToken:s,fromAmount:c(l,s.decimals),toToken:o,toAmount:c(h,o.decimals),priceImpact:y},{type:"build",inputs:[{token:s,amount:c(v,s.decimals)},{token:o,amount:c(I,o.decimals)}],outputToken:n,outputAmount:c(f,n.decimals)},{type:"deposit",token:n,amount:c(f,n.decimals)}]}}async getWithdrawQuoteForType({chain:t,withdrawnToken:e,withdrawnAmountAfterFeeWei:n,shareToken:s,sharesToWithdrawWei:o,actualTokenOut:r,swapTokenIn:a,swapTokenOut:i,option:d,amounts:p,native:m,wnative:w}){const l=U(e.address,d.amm,t);await l.updateAllData();const{amount0:u,amount1:h,token0:y,token1:v}=l.removeLiquidity(n,!0),I=d.lpTokens.find(E=>E.address.toLowerCase()===y.toLowerCase()),f=d.lpTokens.find(E=>E.address.toLowerCase()===v.toLowerCase());if(!I||!f)throw new Error("LP token mismatch");const k=[{token:s,amount:c(o,s.decimals),spenderAddress:d.zap.zapAddress}],L={type:"split",inputToken:e,inputAmount:c(n,e.decimals),outputs:[{token:I,amount:c(u,I.decimals)},{token:f,amount:c(h,f.decimals)}]};if(a===null)return{id:C(d.id),optionId:d.id,type:"zap",allowances:k,inputs:p,outputs:[{token:N(I,w,m),amount:c(u,I.decimals)},{token:N(f,w,m),amount:c(h,f.decimals)}],priceImpact:0,steps:[L]};const Q=a.address.toLowerCase()===y.toLowerCase(),H=Q?u:h,J=Q?h:u,x=H,{amountOut:Z,priceImpact:V}=l.swap(x,a.address),K=J.plus(Z);return{id:C(d.id),optionId:d.id,type:"zap",allowances:k,inputs:p,outputs:[{token:r,amount:c(K,i.decimals)}],priceImpact:V,steps:[L,{type:"swap",fromToken:a,fromAmount:c(x,a.decimals),toToken:i,toAmount:c(Z,i.decimals),priceImpact:V}]}}}class Ft{getId(){return"vault"}async getModeOptionsFor(t,e,n){const s=A(n,e);if(!F(s))return null;const o=[s.depositTokenAddress];return[{id:D("vault",e,s.chainId,o),providerId:"vault",vaultId:e,chainId:s.chainId,tokenAddresses:o,tokensId:S(s.chainId,o),type:"vault",mode:t}]}async getDepositOptionsFor(t,e){return this.getModeOptionsFor(W.Deposit,t,e)}async getDepositQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");const s=A(n,t.vaultId);return{id:C(t.id),optionId:t.id,type:"vault",allowances:e.filter(o=>B(o.token)).map(o=>({token:o.token,amount:o.amount,spenderAddress:s.earnContractAddress})),inputs:e,outputs:e}}async getDepositStep(t,e,n,s){const o=A(n,e.vaultId);return{step:"deposit",message:s("Vault-TxnConfirm",{type:s("Deposit-noun")}),action:O.deposit(o,t.inputs[0].amount,t.inputs[0].max),pending:!1,extraInfo:{vaultId:o.id}}}async getWithdrawOptionsFor(t,e){return this.getModeOptionsFor(W.Withdraw,t,e)}async getWithdrawQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");return{id:C(t.id),optionId:t.id,type:"vault",allowances:[],inputs:e,outputs:e}}async getWithdrawStep(t,e,n,s){const o=et(n,e.vaultId),r=t.inputs[0];return{step:"withdraw",message:s("Vault-TxnConfirm",{type:s("Withdraw-noun")}),action:O.withdraw(o,r.amount,r.max),pending:!1,extraInfo:{vaultId:o.id}}}}class Bt{getId(){return"gov-vault"}async getModeOptionsFor(t,e,n){const s=A(n,e);if(!Ot(s))return null;const o=[s.depositTokenAddress];return[{id:D(this.getId(),e,s.chainId,o),providerId:this.getId(),vaultId:e,chainId:s.chainId,tokenAddresses:o,tokensId:S(s.chainId,o),type:"gov-vault",mode:t}]}async getDepositOptionsFor(t,e){return this.getModeOptionsFor(W.Deposit,t,e)}async getDepositQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");const s=A(n,t.vaultId);return{id:C(t.id),optionId:t.id,type:"gov-vault",allowances:e.filter(o=>B(o.token)).map(o=>({token:o.token,amount:o.amount,spenderAddress:s.earnContractAddress})),inputs:e,outputs:e}}async getDepositStep(t,e,n,s){const o=X(n,e.vaultId);return{step:"deposit-gov",message:s("Vault-TxnConfirm",{type:s("Stake-noun")}),action:O.stakeGovVault(o,t.inputs[0].amount),pending:!1,extraInfo:{vaultId:o.id}}}async getWithdrawOptionsFor(t,e){return this.getModeOptionsFor(W.Withdraw,t,e)}async getWithdrawQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");const s=e[0].max,o=[...e];if(s){const r=X(n,t.vaultId),a=zt(n,r.id),i=T(n,r.chainId,r.earnedTokenAddress);a.gt(b)&&o.push({token:i,amount:a})}return{id:C(t.id),optionId:t.id,type:"gov-vault",allowances:[],inputs:e,outputs:o}}async getWithdrawStep(t,e,n,s){const o=X(n,e.vaultId),r=t.inputs[0];if(t.inputs.every(i=>i.max===!0)&&!1&&t.outputs.length===2&&t.outputs[1].amount.gt(b)){const i=t.outputs[1];return{step:"claim-withdraw",message:s("Vault-TxnConfirm",{type:s("Claim-Withdraw-noun")}),action:O.exitGovVault(o),pending:!1,extraInfo:{rewards:{token:i.token,amount:i.amount},vaultId:o.id}}}return{step:"withdraw",message:s("Vault-TxnConfirm",{type:s("Withdraw-noun")}),action:O.unstakeGovVault(o,r.amount),pending:!1,extraInfo:{vaultId:o.id}}}}class Dt extends mt{constructor(){super("solidly")}async getDepositQuoteForType({web3:t,chain:e,depositToken:n,swapTokenIn:s,swapTokenOut:o,userAmountInWei:r,option:a,vault:i,amounts:d}){const p=U(n.address,a.amm,e),m=new t.eth.Contract(j,a.zap.zapAddress),[[w]]=await p.updateAllData([[{estimate:m.methods.estimateSwap(i.earnContractAddress,s.address,r.toString(10))}]]);if(!w.estimate)throw new Error("Failed to estimate swap.");const l=new ht(w.estimate[0]),u=r.minus(l),{amountOut:h,priceImpact:y}=p.swap(l,s.address,!0),{addAmountA:v,addAmountB:I,liquidity:f}=p.addLiquidity(u,s.address,h);return{id:C(a.id),optionId:a.id,type:"zap",allowances:d.filter(k=>B(k.token)).map(k=>({token:k.token,amount:k.amount,spenderAddress:a.zap.zapAddress})),inputs:d,outputs:[{token:n,amount:c(f,n.decimals)}],priceImpact:y,steps:[{type:"swap",fromToken:s,fromAmount:c(l,s.decimals),toToken:o,toAmount:c(h,o.decimals),priceImpact:y},{type:"build",inputs:[{token:s,amount:c(v,s.decimals)},{token:o,amount:c(I,o.decimals)}],outputToken:n,outputAmount:c(f,n.decimals)},{type:"deposit",token:n,amount:c(f,n.decimals)}]}}async getWithdrawQuoteForType({chain:t,withdrawnToken:e,withdrawnAmountAfterFeeWei:n,shareToken:s,sharesToWithdrawWei:o,actualTokenOut:r,swapTokenIn:a,swapTokenOut:i,option:d,amounts:p,native:m,wnative:w}){const l=U(e.address,d.amm,t);await l.updateAllData();const{amount0:u,amount1:h,token0:y,token1:v}=l.removeLiquidity(n,!0),I=d.lpTokens.find(E=>E.address.toLowerCase()===y.toLowerCase()),f=d.lpTokens.find(E=>E.address.toLowerCase()===v.toLowerCase());if(!I||!f)throw new Error("LP token mismatch");const k=[{token:s,amount:c(o,s.decimals),spenderAddress:d.zap.zapAddress}],L={type:"split",inputToken:e,inputAmount:c(n,e.decimals),outputs:[{token:I,amount:c(u,I.decimals)},{token:f,amount:c(h,f.decimals)}]};if(a===null)return{id:C(d.id),optionId:d.id,type:"zap",allowances:k,inputs:p,outputs:[{token:N(I,w,m),amount:c(u,I.decimals)},{token:N(f,w,m),amount:c(h,f.decimals)}],priceImpact:0,steps:[L]};const Q=a.address.toLowerCase()===y.toLowerCase(),H=Q?u:h,J=Q?h:u,x=H,{amountOut:Z,priceImpact:V}=l.swap(x,a.address),K=J.plus(Z);return{id:C(d.id),optionId:d.id,type:"zap",allowances:k,inputs:p,outputs:[{token:r,amount:c(K,i.decimals)}],priceImpact:V,steps:[L,{type:"swap",fromToken:a,fromAmount:c(x,a.decimals),toToken:i,toAmount:c(Z,i.decimals),priceImpact:V}]}}}function it(g){return g.status==="fulfilled"}const St={value:0};class bt{constructor(){z(this,"ammId","ethereum-conic");z(this,"tokenProviderId","conic");z(this,"depositCache",{});z(this,"withdrawCache",{})}getId(){return"beefy-zap-conic"}async getDepositOptionsFor(t,e){if(t in this.depositCache)return this.depositCache[t];const n=this.getCommonOption(t,e,W.Deposit);return n?(this.depositCache[t]=[n],this.depositCache[t]):null}async getDepositQuoteFor(t,e,n){if(!this.isBeefyZapOption(t))throw new Error(`Wrong option type passed to ${this.getId()}`);const s=A(n,t.vaultId);if(!F(s))throw new Error("Only standard vaults are supported");if(e.length!==1)throw new Error("Only 1 input token supported");const o=M(e);if(o.amount.lte(b))throw new Error("Quote called with 0 input");const r=R(n,t.chainId),a=await q(r),i=new a.eth.Contract(j,t.zap.zapAddress),d=P(n,s.chainId),p=G(o.token,d),m=ut(o.amount,o.token.decimals),w=await i.methods.estimateSwap(s.earnContractAddress,p.address,m.toString(10)).call(),l=T(n,s.chainId,s.depositTokenAddress),u=Y(w.swapAmountOut,l.decimals);return{id:C(t.id),optionId:t.id,type:"zap",allowances:e.filter(h=>B(h.token)).map(h=>({token:h.token,amount:h.amount,spenderAddress:t.zap.zapAddress})),inputs:e,outputs:[{token:l,amount:u}],priceImpact:0,steps:[{type:"build",inputs:[{token:o.token,amount:o.amount}],outputToken:l,outputAmount:u},{type:"deposit",token:l,amount:u}]}}async getDepositStep(t,e,n,s){if(!this.isBeefyZapOption(e))throw new Error(`Wrong option type passed to ${this.getId()}`);const o=A(n,e.vaultId),r=_(n),a=t.inputs[0],i=ct(a.token),d=t.steps.find(m=>m.type==="build");if(!d)throw new Error("No build step in zap quote");const p={type:"swap",fromToken:d.inputs[0].token,fromAmount:d.inputs[0].amount,toToken:d.outputToken,toAmount:d.outputAmount,priceImpact:0};return{step:"zap-in",message:s("Vault-TxnConfirm",{type:s("Deposit-noun")}),action:O.beefIn(o,a.amount,i,p,e.zap,r),pending:!1,extraInfo:{zap:!0,vaultId:o.id}}}async getWithdrawOptionsFor(t,e){if(t in this.withdrawCache)return this.withdrawCache[t];const n=this.getCommonOption(t,e,W.Withdraw);return n?(this.withdrawCache[t]=[n],this.withdrawCache[t]):null}async getWithdrawQuoteFor(t,e,n){if(!this.isBeefyZapOption(t))throw new Error(`Wrong option type passed to ${this.getId()}`);const s=A(n,t.vaultId);if(!F(s))throw new Error("Only standard vaults are supported");if(e.length!==1)throw new Error("Only 1 input token supported");const o=M(e);if(o.amount.lte(b))throw new Error("Quote called with 0 input");const r=T(n,t.chainId,t.tokenAddresses[0]),a=P(n,s.chainId),i=G(r,a),{shareToken:d,sharesToWithdrawWei:p}=lt(o,s,n),m=R(n,t.chainId),w=await q(m),u=await new w.eth.Contract(j,t.zap.zapAddress).methods.estimateSwapOut(s.earnContractAddress,i.address,p.toString(10)).call(),h=T(n,s.chainId,s.depositTokenAddress),y=Y(u.swapAmountIn,h.decimals),v=Y(u.swapAmountOut,r.decimals);return{id:C(t.id),optionId:t.id,type:"zap",allowances:[{token:d,amount:c(p,d.decimals),spenderAddress:t.zap.zapAddress}],inputs:e,outputs:[{token:r,amount:v}],priceImpact:0,steps:[{type:"split",inputToken:h,inputAmount:y,outputs:[{token:r,amount:v}]}]}}async getWithdrawStep(t,e,n,s){if(!this.isBeefyZapOption(e))throw new Error(`Wrong option type passed to ${this.getId()}`);const o=et(n,e.vaultId),r=_(n),a=t.steps.find(d=>d.type==="split");if(!a)throw new Error("No split step in zap quote");const i={type:"swap",fromToken:a.inputToken,fromAmount:a.inputAmount,toToken:a.outputs[0].token,toAmount:a.outputs[0].amount,priceImpact:0};return{step:"zap-out",message:s("Vault-TxnConfirm",{type:s("Withdraw-noun")}),action:O.beefOutAndSwap(o,t.inputs[0],i,e.zap,r),pending:!1,extraInfo:{zap:!0,vaultId:o.id}}}getCommonOption(t,e,n){const s=A(e,t);if(!F(s))return null;const o=T(e,s.chainId,s.depositTokenAddress);if(!B(o)||o.providerId!=this.tokenProviderId)return null;const r=pt(e,this.ammId);if(!r)return null;const a=s.assetIds.map(d=>dt(e,s.chainId,d));if(a.length!=1)return null;const i=[a[0].address.toLowerCase()];return{id:D(this.getId(),t,s.chainId,i),type:"zap",mode:n,providerId:this.getId(),vaultId:t,chainId:s.chainId,tokensId:S(s.chainId,i),tokenAddresses:i,zap:r,amm:void 0,lpTokens:[],fee:St}}isBeefyZapOption(t){return t.providerId===this.getId()}}class xt{constructor(){z(this,"providers",[]);z(this,"providersById",{});this.providers.push(new Ft),this.providers.push(new Bt),this.providers.push(new Et),this.providers.push(new Dt),this.providers.push(new Tt),this.providers.push(new bt),this.providersById=this.providers.reduce((t,e)=>(t[e.getId()]=e,t),{})}async getDepositOptionsFor(t,e){return(await Promise.all(this.providers.map(s=>s.getDepositOptionsFor(t,e)))).filter(s=>!!s).flat()}async getWithdrawOptionsFor(t,e){return(await Promise.all(this.providers.map(s=>s.getWithdrawOptionsFor(t,e)))).filter(s=>!!s).flat()}async getDepositQuotesFor(t,e,n){const s=await Promise.allSettled(t.map(i=>this.providersById[i.providerId].getDepositQuoteFor(i,e,n))),[o,r]=rt(s,it),a=o.map(i=>i.value).filter(i=>!!i).flat();if(r.length>0&&console.warn("getDepositQuotesFor failed",r),a.length>0)return a;throw r.length>0?r[0].reason:new Error("No quotes succeeded")}async getWithdrawQuotesFor(t,e,n){const s=await Promise.allSettled(t.map(i=>this.providersById[i.providerId].getWithdrawQuoteFor(i,e,n))),[o,r]=rt(s,it),a=o.map(i=>i.value).filter(i=>!!i).flat();if(r.length>0&&console.warn("getWithdrawQuotesFor failed",r),a.length>0)return a;throw r.length>0?r[0].reason:new Error("No quotes succeeded")}async getDepositStep(t,e,n,s){return this.providersById[e.providerId].getDepositStep(t,e,n,s)}async getWithdrawStep(t,e,n,s){return this.providersById[e.providerId].getWithdrawStep(t,e,n,s)}}export{xt as TransactApi};
